## 题目（困难）
Alice 和 Bob 两个人轮流玩一个游戏，Alice 先手。

一开始，有 n 个石子堆在一起。每个人轮流操作，正在操作的玩家可以从石子堆里拿走 任意 非零 平方数 个石子。

如果石子堆里没有石子了，则无法操作的玩家输掉游戏。

给你正整数 n ，且已知两个人都采取最优策略。如果 Alice 会赢得比赛，那么返回 True ，否则返回 False 。

 

示例 1：

输入：n = 1
输出：true
解释：Alice 拿走 1 个石子并赢得胜利，因为 Bob 无法进行任何操作。
示例 2：

输入：n = 2
输出：false
解释：Alice 只能拿走 1 个石子，然后 Bob 拿走最后一个石子并赢得胜利（2 -> 1 -> 0）。
示例 3：

输入：n = 4
输出：true
解释：n 已经是一个平方数，Alice 可以一次全拿掉 4 个石子并赢得胜利（4 -> 0）。
示例 4：

输入：n = 7
输出：false
解释：当 Bob 采取最优策略时，Alice 无法赢得比赛。
如果 Alice 一开始拿走 4 个石子， Bob 会拿走 1 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -> 3 -> 2 -> 1 -> 0）。
如果 Alice 一开始拿走 1 个石子， Bob 会拿走 4 个石子，然后 Alice 只能拿走 1 个石子，Bob 拿走最后一个石子并赢得胜利（7 -> 6 -> 2 -> 1 -> 0）。
示例 5：

输入：n = 17
输出：false
解释：如果 Bob 采取最优策略，Alice 无法赢得胜利。
 

提示：

1 <= n <= 10^5

### 解题思路
如果一个状态是必输的状态，那么如果我拿走平方数个石子能让对方到达这个必输状态，那我当前的状态就是必赢；
首先初始化，将所有平方数的状态置为必赢,其他为0，更新时跳过这些状态；
在一个新的状态下，遍历可移走的平方数，如果移走后是必输状态，当前状态就是必赢，且就是最优解；
转移方程为$dp[i] = !dp[i - j^2]$ (只有$dp[i - j^2] == 0$才更新）；

对于拿走后必赢的策略，不做更新，因为选了等于自己输，要找最优的能让自己赢的。

### 代码

```cpp
class Solution {
public:
    bool winnerSquareGame(int n) {
        vector<int> dp(n + 1, 0);
        for(int i = 1; i <= sqrt(n); i++) dp[i*i] = 1;
        for(int i = 1; i <= n; i++) {
            if(dp[i] == 1) continue;
            for(int j = 1; j*j < i; j++) {
                if(dp[i - j*j] == 0) {
                    dp[i] = 1;
                    break;
                }
            }            
        }
        return dp[n];       
    }
};
```
